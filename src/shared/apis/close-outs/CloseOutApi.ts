import { query, collection, updateDoc, doc, deleteDoc, onSnapshot, Unsubscribe, setDoc, getDoc, addDoc } from "firebase/firestore";
import { db } from "../../config/firebase-config";
import AppStore from "../../stores/AppStore";
import AppApi from "../AppApi";
import { ICloseOutDistribution } from "../../models/close-outs/CloseOutModel";

export default class CloseOutDistributionApi {
  constructor(private api: AppApi, private store: AppStore) { }

  private closeOutDistributionPath() {
    return "closeOutDistributions";
  }

  async getAll() {
    this.store.closeOutStore.removeAll();
    const path = this.closeOutDistributionPath();
    if (!path) return;

    const $query = query(collection(db, path));

    return await new Promise<Unsubscribe>((resolve, reject) => {
      const unsubscribe = onSnapshot(
        $query,
        (querySnapshot) => {
          const closeOutDistribution: ICloseOutDistribution[] = [];
          querySnapshot.forEach((doc) => {
            closeOutDistribution.push({
              id: doc.id,
              ...doc.data(),
            } as ICloseOutDistribution);
          });
          this.store.closeOutStore.load(closeOutDistribution);
          resolve(unsubscribe);
        },
        (error) => {
          reject();
        }
      );
    });
  }

  async getById(id: string) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    const unsubscribe = onSnapshot(doc(db, path, id), (doc) => {
      if (!doc.exists) return;
      const item = { id: doc.id, ...doc.data() } as ICloseOutDistribution;
      this.store.closeOutStore.load([item]);
    });

    return unsubscribe;
  }

  async create(item: ICloseOutDistribution) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    const itemRef = doc(collection(db, path))
    item.id = itemRef.id;

    try {
      await setDoc(itemRef, item, { merge: true, })
    } catch (error) {
    }
  }


  async createCloseOut(
    item: ICloseOutDistribution
  ): Promise<ICloseOutDistribution> {
    const path = this.closeOutDistributionPath();
    if (!path) throw new Error("Path not found");

    const itemRef = doc(collection(db, path));
    try {
      await setDoc(itemRef, item, { merge: true });
      const docSnap = await getDoc(itemRef);
      const createdItem = {
        id: docSnap.id,
        ...docSnap.data(),
      } as ICloseOutDistribution;
      return createdItem;
    } catch (error) {
      throw new Error("Error creating document: " + error);
    }
  }

  async createClose(
    item: ICloseOutDistribution
  ): Promise<ICloseOutDistribution> {
    const path = this.closeOutDistributionPath();
    if (!path) throw new Error("Path not found");

    const collectionRef = collection(db, path);

    try {
      // Using Firestore's built-in ID generation
      const docRef = await addDoc(collectionRef, item);
      const docSnap = await getDoc(docRef);
      const createdItem = {
        id: docSnap.id, // Use the id generated by Firestore
        ...docSnap.data(),
      } as ICloseOutDistribution;
      return createdItem;
    } catch (error) {
      throw new Error("Error creating document: " + error);
    }
  }

  async updateStatus(item: ICloseOutDistribution) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    try {
      const updatedItem = { ...item };

      await updateDoc(doc(db, "closeOutDistributions", item.id), updatedItem);
      this.store.closeOutStore.load([updatedItem]);
    } catch (error) {
      // Handle the error as needed
      console.error("Error updating balance:", error);
    }
  }

  async createnew(item: ICloseOutDistribution): Promise<ICloseOutDistribution> {
    const path = this.closeOutDistributionPath();
    if (!path) throw new Error("Path not found");

    const collectionRef = collection(db, path);

    try {
      const docRef = await addDoc(collectionRef, item);
      const createdItem = {
        ...item, // Include the rest of the item's data
      } as ICloseOutDistribution;

      createdItem.id = docRef.id; // Assign the document ID separately

      return createdItem;
    } catch (error) {
      throw new Error("Error creating document: " + error);
    }
  }

  async update(item: ICloseOutDistribution) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    try {
      await updateDoc(doc(db, path, item.id), {
        ...item,
      });
      this.store.closeOutStore.load([item]);
    } catch (error) { }
  }

  // async updateAndCreateAuditTrail(oldTransaction: IWithdrawalTransaction, item: IWithdrawalTransaction) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         await updateDoc(doc(db, path, item.id), {
  //             ...item,
  //         });
  //         this.store.withdrawalTransaction.load([item]);
  //         const auditRecord: IWithdrawalTransactionAudit = {
  //             id: "",
  //             auditDateTime: Date.now(),
  //             action: item.transactionAction || "",
  //             actionDescription: `Transaction was ${item.transactionAction}`,
  //             dataStateBeforeAudit: {
  //                 ...oldTransaction
  //             },
  //             dataStateAfterAudit: {
  //                 ...item
  //             },
  //             actionUser: this.store.auth.meUID || ""
  //         }
  //         try {
  //             await this.api.withdrawalTransactionAudit.create(item.id, auditRecord);
  //         } catch (error) {
  //             console.log(error);
  //         }
  //     } catch (error) { }
  // }

  // async updateBatchStatus(withdrawalId: string) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const querySnapshot = await getDocs(query(collection(db, path), where('id', '==', withdrawalId)));

  //         if (!querySnapshot.empty) {
  //             const document = querySnapshot.docs[0]; // Assuming there's only one document with the given withdrawalId
  //             const docRef = doc(db, path, document.id);

  //             await updateDoc(docRef, {
  //                 batchStatus: true,
  //             });
  //         } else {
  //         }
  //     } catch (error) {

  //     }
  // }

  // async updateBatchStatusAndCreateAuditTrail(oldTransaction: IWithdrawalTransaction, item: IWithdrawalTransaction, withdrawalId: string) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const querySnapshot = await getDocs(query(collection(db, path), where('id', '==', withdrawalId)));

  //         if (!querySnapshot.empty) {
  //             const document = querySnapshot.docs[0]; // Assuming there's only one document with the given withdrawalId
  //             const docRef = doc(db, path, document.id);

  //             await updateDoc(docRef, {
  //                 batchStatus: true,
  //             });
  //             const auditRecord: IWithdrawalTransactionAudit = {
  //                 id: "",
  //                 auditDateTime: Date.now(),
  //                 action: "Added to Batch",
  //                 actionDescription: `Transaction was Added to Batch`,
  //                 dataStateBeforeAudit: {
  //                     ...oldTransaction
  //                 },
  //                 dataStateAfterAudit: {
  //                     ...item
  //                 },
  //                 actionUser: this.store.auth.meUID || ""
  //             }
  //             try {
  //                 await this.api.withdrawalTransactionAudit.create(item.id, auditRecord);
  //             } catch (error) {
  //                 console.log(error);
  //             }
  //         } else {
  //         }
  //     } catch (error) {

  //     }
  // }

  // async updateBatchStatusToFalse(withdrawalId: string) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const querySnapshot = await getDocs(query(collection(db, path), where('id', '==', withdrawalId)));

  //         if (!querySnapshot.empty) {
  //             const document = querySnapshot.docs[0]; // Assuming there's only one document with the given withdrawalId
  //             const docRef = doc(db, path, document.id);

  //             await updateDoc(docRef, {
  //                 batchStatus: false,
  //             });

  //         } else {

  //         }
  //     } catch (error) {

  //     }
  // }

  // async updateBatchStatusToFalseAndCreateAuditTrail(oldTransaction: IWithdrawalTransaction, item: IWithdrawalTransaction, withdrawalId: string) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const querySnapshot = await getDocs(query(collection(db, path), where('id', '==', withdrawalId)));

  //         if (!querySnapshot.empty) {
  //             const document = querySnapshot.docs[0]; // Assuming there's only one document with the given withdrawalId
  //             const docRef = doc(db, path, document.id);

  //             await updateDoc(docRef, {
  //                 batchStatus: false,
  //             });

  //             const auditRecord: IWithdrawalTransactionAudit = {
  //                 id: "",
  //                 auditDateTime: Date.now(),
  //                 action: "Removed from Batched Transactions",
  //                 actionDescription: `Transaction was Removed from Batched Transactions`,
  //                 dataStateBeforeAudit: {
  //                     ...oldTransaction
  //                 },
  //                 dataStateAfterAudit: {
  //                     ...item
  //                 },
  //                 actionUser: this.store.auth.meUID || ""
  //             }
  //             try {
  //                 await this.api.withdrawalTransactionAudit.create(item.id, auditRecord);
  //             } catch (error) {
  //                 console.log(error);
  //             }

  //         } else {

  //         }
  //     } catch (error) {

  //     }
  // }

  // async updateProcessStatus(withdrawalId: string) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const querySnapshot = await getDocs(query(collection(db, path), where('id', '==', withdrawalId)));

  //         if (!querySnapshot.empty) {
  //             const document = querySnapshot.docs[0]; // Assuming there's only one document with the given withdrawalId
  //             const docRef = doc(db, path, document.id);

  //             await updateDoc(docRef, {
  //                 isPaymentProcessed: true,
  //             });

  //             const withdrawal = this.store.withdrawalTransaction.getItemById(document.id);

  //             if (withdrawal) {

  //                 this.store.withdrawalTransaction.select(withdrawal.asJson);

  //                 if (this.store.withdrawalTransaction.selected) {

  //                     const withdrawalAllocation = this.store.withdrawalTransaction.selected;

  //                     const statementTransaction: IStatementTransaction = {
  //                         id: "",
  //                         date: Date.parse(dateFormat_YY_MM_DD(Date.now())),
  //                         transaction: "withdrawal",
  //                         balance: getAccountBalance(withdrawalAllocation.allocation, this.store) - withdrawalAllocation.amount,
  //                         rate: getAccountRate(withdrawalAllocation.allocation, this.store) || 0,
  //                         remark: `Withdraw to account ${withdrawalAllocation.bank}`,
  //                         amount: withdrawalAllocation.amount,
  //                         createdAt: Date.now()
  //                     }

  //                     try {
  //                         await this.api.mma.createStatementTransaction(getAccountId(withdrawalAllocation.allocation, this.store) || "", statementTransaction);
  //                     } catch (error) {

  //                     }
  //                 }
  //             }

  //             console.log(`Batch status updated for withdrawalId: ${withdrawalId}`);
  //         } else {
  //             console.log(`No document found for withdrawalId: ${withdrawalId}`);
  //         }
  //     } catch (error) {
  //         console.error('Error updating batch status:', error);
  //     }
  // }

  // async updateProcessStatusAndCreateAuditTrail(oldTransaction: IWithdrawalTransactionAudit, item: IWithdrawalTransaction, withdrawalId: string) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const querySnapshot = await getDocs(query(collection(db, path), where('id', '==', withdrawalId)));

  //         if (!querySnapshot.empty) {
  //             const document = querySnapshot.docs[0]; // Assuming there's only one document with the given withdrawalId
  //             const docRef = doc(db, path, document.id);

  //             await updateDoc(docRef, {
  //                 isPaymentProcessed: true,
  //             });

  //             console.log(`Batch status updated for withdrawalId: ${withdrawalId}`);
  //         } else {
  //             console.log(`No document found for withdrawalId: ${withdrawalId}`);
  //         }
  //     } catch (error) {
  //         console.error('Error updating batch status:', error);
  //     }
  // }

  // async updateBalanceWithdraw(item: IWithdrawalTransaction, previousBalance: number) {
  //     const path = this.withdrawalTransactionPath();
  //     if (!path) return;

  //     try {
  //         const updatedItem = { ...item, previousBalance: previousBalance };

  //         await updateDoc(doc(db, path, item.id), updatedItem);
  //         this.store.withdrawalTransaction.load([updatedItem]);
  //     } catch (error) {
  //         // Handle the error as needed
  //         console.error("Error updating balance:", error);
  //     }
  // }

  async delete(item: ICloseOutDistribution) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    try {
      await deleteDoc(doc(db, path, item.id));
      this.store.closeOutStore.remove(item.id);
    } catch (error) { }
  }

  async updateApprovalStatus(item: ICloseOutDistribution) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    try {
      await updateDoc(doc(db, path, item.id), {
        isPaymentProcessed: true,
        processedDate: Date.now()
      });
      this.store.closeOutStore.load([item]);
    } catch (error) {
      // Handle the error if needed
    }
  }
  async updateMarkDone(item: ICloseOutDistribution) {
    const path = this.closeOutDistributionPath();
    if (!path) return;

    try {
      await updateDoc(doc(db, path, item.id), {
        completeActive: true,
      });
      this.store.closeOutStore.load([item]);
    } catch (error) {
      // Handle the error if needed
    }
  }
}